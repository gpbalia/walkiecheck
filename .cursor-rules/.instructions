WalkieCheck: A Smarter Way to Manage Radios on Set

In the fast-paced world of film and television production, organization and accountability are everything—especially when it comes to the essential tools that keep communication flowing. WalkieCheck is a modern, web-based application built with Next.js, designed specifically to streamline the way production teams manage walkie-talkies on set. From small indie crews to large-scale productions, the app brings structure, clarity, and control to what has traditionally been a chaotic and manual process.

WalkieCheck offers a sleek, Slack-inspired interface, with intuitive navigation and responsive design suited for both desktop and mobile use. The left-hand sidebar allows users to switch between projects or create new ones, while a collapsible right-hand menu provides access to personal settings, payment information, and user preferences. It’s a clean and efficient layout, designed with real production workflows in mind.

At the heart of the app is its robust project dashboard, where users can add and track walkies by department, crew member, serial number, and status. Each walkie can be marked as assigned, broken, lost, or available, and the system maintains a full audit trail of every action—detailing who made changes, when, and why. The search and filtering tools are comprehensive, allowing users to drill down to exactly the information they need in seconds.

Collaboration is built into the core of WalkieCheck. Users can invite colleagues to join a project with either read-only or admin privileges, ensuring that the right people have access to the right tools at the right time. Every change is logged and time-stamped, creating a transparent environment of shared responsibility.

WalkieCheck also includes advanced reporting features, allowing users to generate detailed logs and export them as PDF or Excel files. These reports can be customized by date range, department, walkie, or crew member—offering producers and coordinators a powerful overview of how equipment is being used, and by whom.

Authentication is handled securely through Firebase, with payments managed via Stripe.

More than just a tracker, WalkieCheck is a centralized command center for radio communication equipment—designed to reduce loss, increase accountability, and make set operations smoother and more professional. In an industry where every detail counts, WalkieCheck ensures that nothing gets lost in transmission.

# Tech Stack Overview

Framework: Next.js 14 (App Router)
Auth & DB: Firebase (Auth, Firestore, Functions)
Payments: Stripe (Monthly/Yearly Plans)
Hosting: Firebase Hosting
Styling: TailwindCSS + ShadCN UI
Icons: Lucide
Auth Protection: Middleware to protect /auth routes
User Roles/Plans: Stored in Firestore and synced with Stripe subscriptions

# Project Folder Structure

walkiecheck/
├── app/
│   ├── layout.tsx
│   ├── page.tsx (default to landing)
│   ├── noauth/
│   │   ├── login/
│   │   │   └── page.tsx
│   │   ├── register/
│   │   │   └── page.tsx
│   │   ├── pricing/
│   │   │   └── page.tsx
│   ├── auth/
│   │   ├── layout.tsx (protected layout)
│   │   ├── dashboard/
│   │   │   └── page.tsx
│   │   ├── project/
│   │   │   ├── [projectId]/
│   │   │   │   ├── page.tsx (main dashboard)
│   │   │   │   ├── crew/
│   │   │   │   ├── departments/
│   │   │   │   ├── walkies/
│   │   │   │   ├── archive/
│   │   │   │   ├── collaborators/
│   │   │   │   ├── report/
│   ├── stripe-webhook/ (API route for Stripe webhook)
├── components/
│   ├── ui/ (ShadCN)
│   ├── layout/
│   ├── auth/
│   ├── dashboard/
├── lib/
│   ├── firebase.ts
│   ├── auth.ts (user session, role check)
│   ├── stripe.ts (client/server utils)
│   ├── firestore.ts (db functions)
├── middleware.ts (protect /auth/* routes)
├── public/
├── styles/
│   └── globals.css
├── .env.local
├── next.config.js
├── firebase.json (hosting config)
└── functions/ (for Stripe webhooks)

# What to Build First
1. Setup Firebase project (Auth + Firestore)
2. Setup Stripe products & test mode
3. Create lib/firebase.ts with config/init
4. Setup Tailwind + ShadCN
5. Build noauth pages: login, register, pricing
6. Configure middleware to guard /auth/**
7. Build dashboard shell + Firestore read/write
8. Integrate Stripe checkout flow
9. Setup webhooks
10. Test roles/plan-based access

# Authentication & Access Control 
Firebase Authentication (Email + Google)

Firestore users collection:

users/{uid} {
  email: string
  name: string
  plan: "free" | "premium"
  stripeCustomerId: string
  activeSubscription: boolean
  subscriptionId: string
}

Middleware protects /auth/** and redirects unauthenticated or unpaid users to /noauth/login.

# Stripe Integration
Stripe products created in dashboard:

monthly_premium

yearly_premium

User signs up → selects plan → redirects to Stripe checkout → webhook listens for checkout.session.completed → updates Firestore user document with active subscription.

Webhook endpoint (/api/stripe-webhook) deployed via Firebase Functions or Next.js route.

# Key Pages
/noauth/login & /noauth/register
Basic form with Firebase auth logic.

On success: redirect to /auth/dashboard.

/noauth/pricing
Plans: Free vs Premium (monthly/yearly buttons)

Stripe Checkout redirect on paid plan

/auth/dashboard
Project list (Create new, access existing)

/auth/project/[projectId]
Main dashboard:

Header (Project name, nav icons)

Search/filter

Action row: Add Walkie, Departments, Crew

Overview Section (Grouped walkies)

Utility row (Collaborators, Report, Archive)

# Sample Firebase Function (Stripe Webhook Handler)
In functions/index.js or /app/api/stripe-webhook/route.ts:

import { buffer } from 'micro';
import * as admin from 'firebase-admin';
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: '2023-10-16' });

export async function POST(req: Request) {
  const rawBody = await req.arrayBuffer();
  const sig = req.headers.get('stripe-signature')!;
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!;

  let event;

  try {
    event = stripe.webhooks.constructEvent(rawBody, sig, webhookSecret);
  } catch (err) {
    return new Response(`Webhook Error: ${err.message}`, { status: 400 });
  }

  if (event.type === 'checkout.session.completed') {
    const session = event.data.object as Stripe.Checkout.Session;
    const customerId = session.customer as string;
    const userId = session.metadata?.userId;

    // Update Firestore user document
    const userRef = admin.firestore().collection('users').doc(userId);
    await userRef.set(
      {
        stripeCustomerId: customerId,
        activeSubscription: true,
        plan: session.metadata?.plan,
      },
      { merge: true }
    );
  }

  return new Response('Webhook received', { status: 200 });
}

